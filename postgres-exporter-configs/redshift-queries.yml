# Custom queries for Redshift-like metrics using PostgreSQL
# These queries simulate Redshift system tables and performance metrics

pg_redshift_query_execution_time:
  query: |
    SELECT 
      datname as database,
      usename as username,
      state,
      COALESCE(EXTRACT(EPOCH FROM (now() - query_start)), 0) as query_duration_seconds,
      COALESCE(EXTRACT(EPOCH FROM (now() - state_change)), 0) as state_duration_seconds,
      CASE 
        WHEN state = 'active' THEN 1 
        ELSE 0 
      END as is_active
    FROM pg_stat_activity 
    WHERE state IS NOT NULL 
      AND datname IS NOT NULL
      AND query NOT LIKE '%pg_stat_activity%'
      AND query NOT LIKE '%postgres_exporter%'
  metrics:
    - database:
        usage: "LABEL"
        description: "Database name"
    - username:  
        usage: "LABEL"
        description: "Username executing the query"
    - state:
        usage: "LABEL" 
        description: "Query state"
    - query_duration_seconds:
        usage: "GAUGE"
        description: "Current query execution time in seconds"
    - state_duration_seconds:
        usage: "GAUGE"
        description: "Time in current state in seconds"
    - is_active:
        usage: "GAUGE"
        description: "Whether query is currently active (1) or not (0)"

pg_custom_query_stats:
  query: |
    SELECT 
      datname as database,
      COALESCE(mean_time, 0) as avg_execution_time_ms,
      COALESCE(total_time, 0) as total_execution_time_ms,
      COALESCE(calls, 0) as total_calls,
      COALESCE(rows, 0) as total_rows,
      query_type
    FROM (
      SELECT 
        d.datname,
        CASE 
          WHEN s.query ILIKE 'SELECT%' THEN 'SELECT'
          WHEN s.query ILIKE 'INSERT%' THEN 'INSERT'
          WHEN s.query ILIKE 'UPDATE%' THEN 'UPDATE'
          WHEN s.query ILIKE 'DELETE%' THEN 'DELETE'
          ELSE 'OTHER'
        END as query_type,
        s.mean_time,
        s.total_time,
        s.calls,
        s.rows
      FROM pg_stat_statements s
      JOIN pg_database d ON d.oid = s.dbid
      WHERE s.query NOT LIKE '%pg_stat%'
        AND s.query NOT LIKE '%postgres_exporter%'
        AND d.datname NOT IN ('postgres', 'template0', 'template1')
      UNION ALL
      SELECT 
        datname,
        'TOTAL' as query_type,
        0 as mean_time,
        0 as total_time, 
        numbackends as calls,
        0 as rows
      FROM pg_stat_database
      WHERE datname NOT IN ('postgres', 'template0', 'template1')
    ) combined_stats
  metrics:
    - database:
        usage: "LABEL"
        description: "Database name"
    - query_type:
        usage: "LABEL"
        description: "Type of SQL query"
    - avg_execution_time_ms:
        usage: "GAUGE" 
        description: "Average query execution time in milliseconds"
    - total_execution_time_ms:
        usage: "GAUGE"
        description: "Total execution time in milliseconds"
    - total_calls:
        usage: "GAUGE"
        description: "Total number of query calls"
    - total_rows:
        usage: "GAUGE"
        description: "Total rows returned/affected"

pg_custom_table_performance:
  query: |
    SELECT 
      schemaname,
      tablename,
      COALESCE(seq_scan, 0) as sequential_scans,
      COALESCE(seq_tup_read, 0) as sequential_tuples_read,
      COALESCE(idx_scan, 0) as index_scans,
      COALESCE(idx_tup_fetch, 0) as index_tuples_fetched,
      COALESCE(n_tup_ins, 0) as tuples_inserted,
      COALESCE(n_tup_upd, 0) as tuples_updated,
      COALESCE(n_tup_del, 0) as tuples_deleted,
      CASE 
        WHEN (seq_scan + COALESCE(idx_scan, 0)) > 0 
        THEN ROUND((COALESCE(idx_scan, 0)::numeric / (seq_scan + COALESCE(idx_scan, 0))) * 100, 2)
        ELSE 0 
      END as index_scan_ratio_percent
    FROM pg_stat_user_tables
    WHERE schemaname = 'public'
  metrics:
    - schemaname:
        usage: "LABEL"
        description: "Schema name"
    - tablename:
        usage: "LABEL"
        description: "Table name"
    - sequential_scans:
        usage: "GAUGE"
        description: "Number of sequential scans"
    - sequential_tuples_read:
        usage: "GAUGE"
        description: "Number of tuples read by sequential scans"
    - index_scans:
        usage: "GAUGE"
        description: "Number of index scans"
    - index_tuples_fetched:
        usage: "GAUGE"
        description: "Number of tuples fetched by index scans"
    - tuples_inserted:
        usage: "GAUGE"
        description: "Number of tuples inserted"
    - tuples_updated:
        usage: "GAUGE"
        description: "Number of tuples updated"
    - tuples_deleted:
        usage: "GAUGE"
        description: "Number of tuples deleted"
    - index_scan_ratio_percent:
        usage: "GAUGE"
        description: "Percentage of scans that used indexes vs sequential scans"

pg_custom_connection_stats:
  query: |
    SELECT 
      datname as database,
      state,
      COUNT(*) as connection_count,
      COALESCE(AVG(EXTRACT(EPOCH FROM (now() - query_start))), 0) as avg_query_duration_seconds,
      COALESCE(MAX(EXTRACT(EPOCH FROM (now() - query_start))), 0) as max_query_duration_seconds
    FROM pg_stat_activity
    WHERE datname IS NOT NULL
    GROUP BY datname, state
  metrics:
    - database:
        usage: "LABEL"
        description: "Database name"
    - state:
        usage: "LABEL"
        description: "Connection state"
    - connection_count:
        usage: "GAUGE"
        description: "Number of connections in this state"
    - avg_query_duration_seconds:
        usage: "GAUGE"
        description: "Average query execution time for connections in this state"
    - max_query_duration_seconds:
        usage: "GAUGE"
        description: "Maximum query execution time for connections in this state"